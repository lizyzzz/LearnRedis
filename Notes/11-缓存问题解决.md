### 13. 应用问题解决
#### 13.1 缓存穿透
* **问题定义**: key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源(数据库)，从而可能压垮数据源(数据库)。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。  
* 由于:
&emsp;&emsp;(1)服务器压力过大, 出现很多非正常的访问导致**非正常的查询**;  
* 导致如下问题:  
&emsp;&emsp;(1)**redis 命中率降低**;  
&emsp;&emsp;(2)一直查询持久化的数据库(如 MySQL), 导致数据库压力过大甚至崩溃.  
![image-15](https://github.com/lizyzzz/LearnRedis/blob/main/images/15.png)  
* 常见的解决方案:
&emsp;&emsp;(1)**对空值缓存**：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。  
&emsp;&emsp;(2)**设置可访问的名单（白名单）**：使用`bitmaps`类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。  
&emsp;&emsp;(3)**采用布隆过滤器**：（布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。  
&emsp;&emsp;(4)**进行实时监控**：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。  

#### 13.2 缓存击穿
* **问题定义**: key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。  
* 由于:  
&emsp;&emsp;(1)redis 某个 key 过期了，刚好有大量的访问使用了这个 key  
&emsp;&emsp;(2)redis 里面没有出现大量 key 过期  
&emsp;&emsp;(3)redis 正常运行  
* 导致:
&emsp;&emsp;(1)数据库访问压力瞬时增加  
![image-16](https://github.com/lizyzzz/LearnRedis/blob/main/images/16.png)  
* 常见的解决方案:  
&emsp;&emsp;(1)**预先设置热门数据**：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长。  
&emsp;&emsp;(2)**实时调整**：现场监控哪些数据热门，实时调整key的过期时长  
&emsp;&emsp;(3)**使用锁**(效率低)：  
&emsp;&emsp;&emsp;&emsp;(a)就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。  
&emsp;&emsp;&emsp;&emsp;(b)先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX ）去set一个 mutex key  
&emsp;&emsp;&emsp;&emsp;(c)当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；  
&emsp;&emsp;&emsp;&emsp;(d)当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法  
![image-17](https://github.com/lizyzzz/LearnRedis/blob/main/images/17.png)  

#### 13.3 缓存雪崩
* **问题定义**: 大量 key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。**缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问.**  
* 由于:  
&emsp;&emsp;(1)在极少的时间段内，查询大量 key 的集中过期情况  
* 导致:  
&emsp;&emsp;(2)数据库访问压力瞬时增加  
![image-18](https://github.com/lizyzzz/LearnRedis/blob/main/images/18.png)  
* 常见的解决方案:  
&emsp;&emsp;(1)**构建多级缓存架构**：nginx缓存 + redis缓存 +其他缓存（ehcache等）  
&emsp;&emsp;(2)**使用锁或队列**：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。**不适用高并发情况**  
&emsp;&emsp;(3)**设置过期标志更新缓存**：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。  
&emsp;&emsp;(4)**将缓存失效时间分散开**：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。  


